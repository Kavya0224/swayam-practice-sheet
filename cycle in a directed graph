class Solution {
  public:
    // Helper function for DFS-based cycle detection
    bool helper(int u, vector<bool>& vis, vector<bool>& rec, vector<vector<int>>& adj) {
        vis[u] = true;      // Mark node as visited
        rec[u] = true;      // Add node to current recursion stack

        // Traverse all neighbors
        for (int v : adj[u]) {
            if (!vis[v]) {
                // If not visited, recurse on it
                if (helper(v, vis, rec, adj))
                    return true;   // Cycle found
            }
            // If neighbor is in recursion stack â†’ cycle exists
            else if (rec[v]) {
                return true;
            }
        }

        rec[u] = false;  // Remove node from recursion stack before returning
        return false;
    }

    // Function to detect cycle in a directed graph
    bool isCyclic(int V, vector<vector<int>> &edges) {
        // Step 1: Build adjacency list
        vector<vector<int>> adj(V);
        for (auto &e : edges) {
            int u = e[0];
            int v = e[1];
            adj[u].push_back(v); // directed edge u -> v
        }

        // Step 2: Initialize visited and recursion stack arrays
        vector<bool> vis(V, false);
        vector<bool> rec(V, false);

        // Step 3: Check for cycle in each component
        for (int i = 0; i < V; i++) {
            if (!vis[i]) {
                if (helper(i, vis, rec, adj))
                    return true;  // Cycle found
            }
        }

        return false;  // No cycle found
    }
};
