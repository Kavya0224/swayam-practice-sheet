/*
Definition for binary tree node:
class Node {
  public:
    int data;
    Node* left;
    Node* right;

    Node(int val) {
        data = val;
        left = nullptr;
        right = nullptr;
    }
};
*/

class Solution {
  public:
    vector<int> topView(Node *root) {
        if (!root) return {}; // If the tree is empty, return an empty vector

        // Queue for BFS traversal: stores pairs of (node, horizontal distance)
        queue<pair<Node*, int>> q;

        // Map to store the first node at each horizontal distance
        // Keys are horizontal distances; values are node->data
        // Using map to keep keys sorted (for left-to-right top view)
        map<int, int> m;

        // Start BFS with the root at horizontal distance 0
        q.push({root, 0});

        while (!q.empty()) {
            Node* node = q.front().first;   // Current node
            int hd = q.front().second;      // Horizontal distance from root
            q.pop();

            // If this horizontal distance is not already present in the map,
            // it means this is the topmost node at this horizontal level
            if (m.find(hd) == m.end()) {
                m[hd] = node->data;
            }

            // Enqueue left child with horizontal distance -1
            if (node->left) {
                q.push({node->left, hd - 1});
            }

            // Enqueue right child with horizontal distance +1
            if (node->right) {
                q.push({node->right, hd + 1});
            }
        }

        // Collect the top view nodes from left to right
        vector<int> ans;
        for (auto& it : m) {
            ans.push_back(it.second);
        }

        return ans;
    }
};
